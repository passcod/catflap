use crate::check_address;
use clap::{App, AppSettings, Arg, ArgMatches};
use std::str::FromStr;

pub fn parse() -> ArgMatches<'static> {
    App::new(env!("CARGO_PKG_NAME"))
        .setting(AppSettings::DontCollapseArgsInUsage)
        .setting(AppSettings::StrictUtf8)
        .version(env!("CARGO_PKG_VERSION"))
        .about(env!("CARGO_PKG_HOMEPAGE"))
        .usage("catflap [options] [address]... -- <command> [args...]")
        .arg(Arg::with_name("env")
             .short("e")
             .long("env")
             .help("Variable to set to a comma-separated list of FDs (- to disable)")
             .value_name("name")
             .default_value("LISTEN_FD")
        )
        .arg(Arg::with_name("nenv")
             .short("E")
             .long("nenv")
             .help("Variable to set to the number of opened sockets (- to disable)")
             .value_name("name")
             .default_value("LISTEN_FDS")
        )
        .arg(Arg::with_name("port base")
            .short("p")
            .long("port-base")
            .help("Ports left off are auto-generated starting from here")
            .value_name("port")
            .default_value("5000")
            .validator(|port| u16::from_str(&port).map(|_| ()).map_err(|e| e.to_string()))
        )
        .arg(Arg::with_name("address")
            .multiple(true)
            .help("Address to listen on, in URL format")
            .validator(check_address)
        )
        .arg(Arg::with_name("command")
            .multiple(true)
            .required(true)
            .last(true)
            .help("Command to execute, followed by its arguments")
        )
        .after_help("Creates IP sockets and passes their descriptors to a child process using environment variables (by default, in systemd style, with the number of provided FDs in `LISTEN_FDS` - FDs start at 3). The child (or any descendants) can then bind the socket. This is useful for server auto-reloaders, as it avoids EADDRINUSE and dropping requests.\n\nAddress format examples:\n- 127.0.0.1\t\t: TCP/IPv4 on 127.0.0.1 on auto-generated port (5000)\n- [::1]:2020\t\t: TCP/IPv6 on ::1 on port 2020\n- tcp://domain:1234\t: TCP on first resolved IP for domain, on port 1234\n- tcp://127.0.0.1:0\t: TCP/IPv4 on 127.0.0.1 on random high port")

        .get_matches()
}
